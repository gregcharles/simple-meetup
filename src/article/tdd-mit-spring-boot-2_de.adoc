= Test-driven Development mit Spring Boot 2: Keine Ausreden gegen Integrationstest
Michael Simons <michael.simons@innoq.com>
:doctype: article
:source-highlighter: coderay
:icons: font
:sectlink: true,
:sectanchors: true,
:numbered: true

[abstract]
--
Am Anfang eines Projektes wird heutzutage in der Regel Wert auf Tests gelegt. Projekte werden sogar als Test-getrieben aufgesetzt (Test-driven-development, TDD). Schleicht sich Streß ein oder lässt die Begeisterung nach, kann es passieren, dass das Thema Tests, obwohl wichtig, vernachlässigt werden. Das gilt umso mehr, je schwieriger Komponenten eines Systems zu testen sind, unabhängig, ob sie einzeln oder integriert betrachtet werden.
--

Der Ihnen vorliegende Artikel hat eine andere Form angenommen als geplant. Ursprünglich wollte ich Ihnen einen testgetriebenen Entwicklungsansatz auf Basis von Spring Boot 2 und JUnit 5 vorstellen. Sie werden im folgenden immer noch über testgetriebene Entwicklung lesen und auch Spring Boot 2 kommt weiterhin vor -- ebenso wie JUnit -- allerdings weit weniger technisch, als geplant.

== Formale Korrektheit oder Erfüllung von Anforderungen?

Treten Sie kurz zurück und fragen sich, welches Ziel Sie mit ihren Tests erreichen möchten. Soll die formale Korrektheit Ihrer Software bewiesen werden oder möchten Sie sicherstellen, dass die Software alle ihr gestellten Anforderungen erfüllt, den Qualitätsansprüchen genügt und im Zusammenhang mit anderen Komponenten in Betrieb genommen werden kann? Dieser Artikel beschäftigt sich mit letzterem. Er fokusiert auf Tests, die bewerten, ob eine Software die an sie gestellten Anforderungen für den geplanten Einsatz erfüllt. Das Thema "Testen" als Gesamtheit zur Überprüfung und Verbesserung von Softwarequalität (Testplanung, -vorbereitung, -steuerung, -durchführung und Dokumentation) ist nicht Bestandteil dieses Textes.

Bevor Sie weiterlesen: Für Softwaretests hinsichtlich Anforderungen gilt oftmals das gleiche wie für Besuche beim Arzt. Eine Diagnose stellt fest, dass es keine Beweise für eine Krankheit gibt. Beweise für die Abwesenheit einer Krankheit gibt es nicht. Sie werden es schwer haben, in einem alltäglichen Projekt, die Abwesenheit von Fehlern hinsichtlich Anforderungen zu beweise.

== Vertrauensbildende Maßnahmen: Tests und Dokumentation

Tests und Dokumentation sind wichtige Aspekte einzelner Anwendungen und sicherlich der meisten Anwendungssysteme. Beide Themen sind gleichermaßen vielschichtig und finden auf unterschiedlichen Ebenen statt:

* Methodenebene
* Klassenebene
* Modulebene
* Systemebene

Genauso unterschiedlich wie die Ebenen sind die Einzelziele. Tests werden oftmals genutzt, um die Korrektheit von Komponenten nachzuweisen. Das sind dann in der Regel Unittests. Der nächste Schritt ist sicherzustellen, dass Komponenten untereinander funktionieren. Es wird von Integrationstests gesprochen. Regressionstests können sowohl als Unit- als auch Integretionstest ausgeprägt sein. Regressionstests sollen Fehler nach Änderungen von Komponenten aufdecken, das heißt, dass Regresionstests wiederholbar sein müssen, um das Ergebnis eines alten mit dem Ergebnis eines neuen Testfalls vergleichen zu können.

Hinsichtlich Dokumentation ist das Feld ähnlich vielfältig. Es wird von Code-, API-, Architektur- und Anwenderdokumentation gesprochen.

Trotz aller Unterschiede gibt es eine Gemeinsamkeit: Die genannten Maßnahmen schaffen Vertrauen. Vertrauen in die Funktionalität als solches, in die Integrierbarkeit eines Systems und auch darauf, Änderungen vornehmen zu können.

== Warum sparen wir uns dennoch das Testen?

Konsequente Softwaretests -- so sie denn gesetzlich nicht vorgeschrieben sind -- stehen oftmals hinten an oder sind nicht integraler Bestandteil von Softwareentwicklung. Im Projektalltag habe ich oft Varianten folgender Argumente gehört: "Dafür ist keine Zeit da." und "Testen schafft sowieso keinen Mehrwert.",  "Diese Module sind nicht testbar." oder auch  "Das benutzte Framework macht Tests zu aufwändig."

Dem gegenüber seit entgegnet:

* Die Zeit wird in Summe so oder so aufgewendet. Vielleicht nicht durch dasselbe Team, das einen Service erstellt hat, aber dann durch das Wartungsteam oder den Support. Die nachträgliche Fehlersuche und insbesonder das dann hoffentlich durchgeführte Testen sind teurer.
* Testen schafft Vertrauen. Vertrauen, das Refactorings und neue Features unterstützt und damit direkt Mehrwert entspricht.
* Code, von dem bekannt ist, dass er getestet wird, wird von Anfang an anders und in meinen Augen besser strukturiert, so dass er testbar bleibt

Schleicht sich in einem Projekt Streß ein, sei es durch zeitlichen Druck, unklare Anforderungen oder anderes mehr, ist es zu spät, Testen noch in den Fokus zu rücken. Hinterher Tests zu schreiben bringt oftmals keinen direkten Mehrwert mehr und eine Nachdokumentation macht selten Spaß.

== Anforderungen an Werkzeuge und Tests

Es ergeben sich aus den einleitenden Abschnitten mindestens die folgenden Anforderungen an Tests:

* Der Start eines Projektes darf mit Testunterstützung nicht aufwändiger sein als ohne
* Die Tests müssen sich nahtlos in den Entwicklungsprozess integrieren
* Sie müssen so schnell wie möglich ausführbar sein
* Das Ergebnis sollte meßbar sein

Die Teams hinter Spring und Spring Boot legen großen Wert darauf, dass ihre Frameworks einen test-getriebenen Softwareenwicklungsansatz unterstützen. Meiner Erfahrung nach trifft das zu.

In der Java-Welt hat sich http://junit.org[JUnit] als Standardwerkzeug zur Ausführung von Tests durchgesetzt. JUnit wird von Spring -- auch in der aktuellsten Version 5 -- vollumfänglich unterstützt.

.Spring und Spring Boot
****
Im Januar 2018 wird mein Buch "Spring Boot -- Moderne Softwareentwicklung im Spring-Ökosystem" im dpunkt.verlag erscheinen. Das Buch ist bereits heute unter http://springbootbuch.de[springbootbuch.de] vorbestellbar. Es adressiert sowohl Spring-Neulinge als auch erfahrene Spring-Entwickler, die jetzt mit Spring Boot arbeiten möchten. Hier ein kurzer Auszug, der Ihnen einen Überblick geben soll, was Spring eigentlich ist.

Das Spring-Framework wurde 2002 erstmals als Idee vorgestellt und ein Jahr später unter dem Namen Spring-Framework als quelloffenes Projekt veröffentlicht. Das Ziel -- damals wie heute -- ist die Entwicklung mit Java zu vereinfachen und gute Programmierpraktiken zu fördern.

Kernfunktionen von Spring sind dabei:

* Dependency Injection
* MVC-basierte Webanwendungen und RESTful Webservices
* Grundlagen für JDBC, JPA und vieles mehr
* aspektorientierte Programmierung und deklarative Behandlung von Transaktionen

Spring Boot ist in diesem Kontext kein neues Framework, sondern eine Sicht auf die Spring-Platform, die es ermöglicht, eigenständige und produktionsreife Anwendungen auf Basis des beschriebenen Spring-Frameworks zu bauen, die unter anderem folgende Eigenschaften haben:

* eigenständige Anwendungen, die keine externen Laufzeitabhängigkeiten mehr haben
* automatische Konfiguration
****

Spring-Boot-Anwendungen sind ganz normale Java-Anwendungen, die in der Regel mit einem Build-Management-Tool gebaut werden. Das Build-Management-Tool ist unter anderem für die Auflistung aller Abhängigkeiten zuständig. Im Beispielprojekt zum Artikel verwende ich das Werkzeug https://gradle.org[Gradle].

Spring Boot arbeitet mit sogenannten Startern. Diese Starter stellen Ihnen alle für ein gegebenes Thema notwendigen Abhängigkeiten zur Verfügung. So einen Starter gibt es auch für das Thema Testen.

Die Deklaration der Abhängigkeit in einem Gradle-Build-File (`build.gradle`) ist sehr einfach:

[source,groovy]
.build-gradle
----
include::../../build.gradle[tags=test-dependencies]
----

Durch nur eine Deklaration erhalten Sie:

* JUnit (in der Version 4)
* Springs Test-Support
* http://site.mockito.org[Mockito], eine Mocking-Library, dazu später mehr
* http://joel-costigliola.github.io/assertj[AssertJ], eine Library, die es Ihnen ermöglicht, sehr expressiv Behauptungen zu erwarteten Ergebnissen zu formulieren

== Das Beispiel

Ich möchte Ihnen anhand einer einfachen Fachlichkeit zeigen, wie Spring Boot 2 Ihnen dabei hilft, sehr einfach Integrationstests zu schreiben: Sei es als vollständiger Durchstich oder als Integrationstest auf einer technischen Ebene.

Gestestet werden soll ein Service, der Events und dazugehörige Registrierungen verwaltet. Ein einem Tag können mehrere Events stattfinden, die Namen der Events müssen dabei eindeutig sein. Events haben eine begrenzte Teilnehmeranzahl. Interesierte Besucher melden sich mit Namen und einer E-Mail-Adresse an und sollen sich nicht mehrfach anmelden können. Von einem Event soll zum vorherigen und nächstem Event navigiert werden können. Der Dienst stellt dazu eine einfache Oberfläche zur Verfügung.

Das Thema könnte Teil einer größeren Anwendung sein und als sogenannter Bounded-Context, einem Begriff aus dem Domain-Driven Design, identifiziert worden sein. Sie finden den vollständigen Quelltext dieses Artikels auf https://github.com/michael-simons/tdd-mit-spring-boot-2[GitHub].

Die Fachlichkeit eignet sich außerdem sehr gut, zu zeigen, dass Tests auf Modulebene nicht nur sehr einfach zu realisieren, sondern auch oftmals die wichtigsten Aspekte Ihrer Domain bereits erfassen. Betrachten Sie folgende Java-Klasse

[source,java]
.Event.java
----
include::../main/java/ac/simons/tdd/domain/Event.java[tags=eventStructure]
----
<1> Der Konstruktor überprüft alle geforderten Vorbedingungen. Client-Code kann kein ungültiges Event herstellen
<2> Die Registrierung selber: Es ist nicht notwendig, Logik dieser Art über einen Service zu implementieren und das Event auf ein blutleeres Modell (anemic domain model) zu reduzieren.

Ansonsten ist die Klasse frei von Spring typischen Annotationen. Schauen Sie in den vollständigen Quelltext finden Sie allerdings JPA-Annotationen. JPA steht für _Java Persistence API_ und wird genutzt, um die Inhalte relationaler Datenbanken auf Objekte abzubilden. Richtig genutzt können Sie damit auf der einen Seite gut gestaltete Schemata mit einem Domain-orientierten Ansatz zufriedenstellend zusammen bringen.

== Die Tests

=== Auf Modul-(Unit)-Ebene

Die Klasse `Event` wird in einem Domain-driven Design Ansatz als Aggregate-Root bezeichnet, als Kern Ihrer Domain. Sie ist Kernbestandteil dessen, was Sie mit Ihrer Software erreichen möchten. Mit den eingangs erwähnten Starter erhalten Sie alle Bausteine, um diese Klasse einem Unit-Test zu unterziehen. Testen Sie ganz klassisch Pre- und Postconditions, wie die Listings <<EventTest-1>> und <<EventTest-2>> zeigen.

[source,java]
[[EventTest-1]]
.Preconditions
----
include::../test/java/ac/simons/tdd/domain/EventTest.java[tags=unitTestExamplePre,indent=0]
----
<1> Signalisiert, dass diese Methode von JUnit als Testmethode ausgeführt werden soll
<2> Hier sehen Sie eine AssertJ-Assertion. AssertJ bietet unter anderem eine schöne Möglichkeit an, zu testen, ob eine bestimmte Exception geworfen wurde oder nicht.
<3> Weiterhin ist es möglich, Assertions aufeinander aufzubauen: Wenn die Exception dem erwarteten Typen entsprach, wird zusätzlich die entsprechende Mitteilung überprüft.

[source,java]
[[EventTest-2]]
.Postconditions
----
include::../test/java/ac/simons/tdd/domain/EventTest.java[tags=unitTestExamplePost,indent=0]
----

Der Test der Logik ist ähnlich aufgebaut. Der Test ist klar strukturiert und gut lesbar, insbesondere weil die zu testende Klasse die Domain gut wiederspiegelt. Mit wenig Aufwand haben Sie den Kern Ihres Geschäftes fast vollständig getestet. Sie haben fast keinen Aufwand in das Aufsetzen einer Testumgebung oder die Bereitstellung von Kollaborateuren der Testklasse stecken mmüssen. Der Test ist also sehr günstig zu haben. Nutzen Sie diese Tatsache aus.

.Warum nicht JUnit 5?
****
Die Klassen in den Listings sind statische Klassen. Das bedeutet, sie sind Bestandteil äußerer Klassen. In unserem Beispiel hat das technische Gründe. Ich möchte die Tests der Klasse `Event` sinnvoll strukturieren. Dabei benötige ich Lösungen, die mir Version 4 von JUnit zur Verfügung stellt. Es wird dabei eine Testsuite auf Basis statischer, innerer Klassen zusammengestellt. Das ist ein wenig sperrig, aber funktioniert.

JUnit 5 erschien im Herbst 2017. Es hat viele neue Funktionen, unter anderem die Möglichkeit, Testklassen als `@Nested` zu markieren. Darüber hinaus vereinfacht es den Umgang mit parametrisierten Tests und das Testen von Exceptions. JUnit 5 kann dynamische Tests (das sind Tests, die erst zur Laufzeit generiert werden) ausführen und mit `@DisplayName` sinnvolle Namen vergeben. Default-Methoden in Interfaces können als `@Test` annotiert werden und so als Mix-In in andere Tests gebracht werden. Die aktuelle Version des Spring-Frameworks unterstützt JUnit 5 ebenfalls und kann zum Beispiel Tests auf Basis des Spring-Containers deaktivieren.

Warum also nicht direkt in diesem Artikel JUnit 5 nutzen? Ich sprach eingangs davon, dass es wichtig ist, dass Tests einfach bereitgestellt werden können. Bürden Sie Ihren Entwicklern zuviel Aufwand zum Testen auf, wird nicht getestet. Während die Unterstützung von JUnit 5 in den großen IDEs wie Eclipse und IntelliJ IDEA bereits sehr gut ist, funktioniert die Build-Tool-Unterstützung noch nicht wie erwartet. Das Beispielprojekt zum Artikel arbeitete ursprünglich mit JUnit 5 und ich hätte Stand November 2017 einen eigenen Aufsatz darüber schreiben können, wie man Gradle beziehungsweise Maven dazu bringt, ähnlich gut mit JUnit 5 zusammenzuarbeiten wie mit Version 4. Ich habe mich bewusst dagegen entschieden, um tatsächlich den Fokus auf einfaches Testen zu legen.
****

=== Fließende Grenzen

Die Events kommen aber nicht aus dem luftleeren Raum. Sie werden in einer Datenbank gespeichert und es muss eine Schnittstelle geben, sie abzurufen. Ich empfehle für Datenbankzugriff vielfältiger Art eines der vielen http://projects.spring.io/spring-data/[Spring-Data-Module]. Spring Data implementiert für Domain-Klassen das Repository-Pattern. Ein Repository dient als Schnittstelle zwischen der Domainschicht und dem technischen Zugriff auf Daten. Nach außen stellt es sich oftmals als eine Art Liste von Domainobjekten da. Spring Data arbeitet dabei deklarativ. <<SpringDataRepository>> zeigt den notwendigen Code für ein Repository von Events.

[source,java]
[[SpringDataRepository]]
.EventRepository.java
----
include::../main/java/ac/simons/tdd/domain/EventRepository.java[tags=eventRepositoryStructure,indent=0]
----

In einer Spring-Boot-Anwendung, die den entsprechenden Spring-Data-Starter als Abhängigkeit deklariert, ist das alles, was Sie tun müssen, um ein Repository dieser Art zur Laufzeit zu erhalten. Dieses Repository müssen Sie nicht testen. In dieser Form gehe ich davon aus, dass das Spring-Data-Team den Code getestet hat, der zur Laufzeit die `save`-Methode implementiert. Was ist aber mit dem Domain-Service in <<EventService>>, der sicherstellt, dass keine doppelten Events gespeichert werden?

[source,java]
[[EventService]]
.Speichern von Events
----
include::../main/java/ac/simons/tdd/domain/EventService.java[tags=eventServiceSaveEvents,indent=0]
----


== Weitere Herausforderungen

* Continous delivery, schnelle tests
* unabhängiges testen von services
* pro weniger tests


== Just testing

include::../../build/generated-api-doc/get-event/curl-request.adoc[]
include::../../build/generated-api-doc/get-event/http-response.adoc[]
include::../../build/generated-api-doc/get-event/response-fields.adoc[]

== Über den Autor

{author} arbeit als Senior Consultant bei https://www.innoq.com/de/[innoQ Deutschland]. Er ist Mitglied des NetBeans Dream Team und Gründer der Euregio JUG. Michael schreibt in seinem http://info.michael-simons.eu[Blog] über Java, Spring und Softwarearchitektur. {firstname} ist Autor des im Januar 2018 erscheinenden Spring Boot Buches.

Auf Twitter unterwegs als @rotnroll666, unter anderem mit Java, Music und den kleineren und größeren Problemen als Ehemann und Vater von 2 Kindern.