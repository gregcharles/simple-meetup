= Test-driven Development mit Spring Boot 2: Keine Ausreden gegen Integrationstest
Michael Simons <michael.simons@innoq.com>
:doctype: article
:source-highlighter: coderay
:icons: font
:sectlink: true,
:sectanchors: true,
:numbered: true

[abstract]
--
Am Anfang eines Projektes wird heutzutage in der Regel Wert auf Tests gelegt. Projekte werden sogar als Test-getrieben aufgesetzt (Test-driven-development, TDD). Schleicht sich Streß ein oder lässt die Begeisterung nach, kann es passieren, dass das Thema Tests, obwohl wichtig, vernachlässigt werden. Das gilt umso mehr, je schwieriger Komponenten eines Systems zu testen sind, unabhängig, ob sie einzeln oder integriert betrachtet werden.
--

Der Ihnen vorliegende Artikel hat eine andere Form angenommen als geplant. Ursprünglich wollte ich Ihnen einen testgetriebenen Entwicklungsansatz auf Basis von Spring Boot 2 und JUnit 5 vorstellen. Sie werden im folgenden immer noch über testgetriebene Entwicklung lesen und auch Spring Boot 2 kommt weiterhin vor -- ebenso wie JUnit -- allerdings weit weniger technisch, als geplant.

== Formale Korrektheit oder Erfüllung von Anforderungen?

Treten Sie kurz zurück und fragen sich, welches Ziel Sie mit ihren Tests erreichen möchten. Soll die formale Korrektheit Ihrer Software bewiesen werden oder möchten Sie sicherstellen, dass die Software alle ihr gestellten Anforderungen erfüllt, den Qualitätsansprüchen genügt und im Zusammenhang mit anderen Komponenten in Betrieb genommen werden kann? Dieser Artikel beschäftigt sich mit letzterem. Er fokusiert auf Tests, die bewerten, ob eine Software die an sie gestellten Anforderungen für den geplanten Einsatz erfüllt. Das Thema "Testen" als Gesamtheit zur Überprüfung und Verbesserung von Softwarequalität (Testplanung, -vorbereitung, -steuerung, -durchführung und Dokumentation) ist nicht Bestandteil dieses Textes.

Bevor Sie weiterlesen: Für Softwaretests hinsichtlich Anforderungen gilt oftmals das gleiche wie für Besuche beim Arzt. Eine Diagnose stellt fest, dass es keine Beweise für eine Krankheit gibt. Beweise für die Abwesenheit einer Krankheit gibt es nicht. Sie werden es schwer haben, in einem alltäglichen Projekt, die Abwesenheit von Fehlern hinsichtlich Anforderungen zu beweise.

== Vertrauensbildende Maßnahmen: Tests und Dokumentation

Tests und Dokumentation sind wichtige Aspekte einzelner Anwendungen und sicherlich der meisten Anwendungssysteme. Beide Themen sind gleichermaßen vielschichtig und finden auf unterschiedlichen Ebenen statt:

* Methodenebene
* Klassenebene
* Modulebene
* Systemebene

Genauso unterschiedlich wie die Ebenen sind die Einzelziele. Tests werden oftmals genutzt, um die Korrektheit von Komponenten nachzuweisen. Das sind dann in der Regel Unittests. Der nächste Schritt ist sicherzustellen, dass Komponenten untereinander funktionieren. Es wird von Integrationstests gesprochen. Regressionstests können sowohl als Unit- als auch Integretionstest ausgeprägt sein. Regressionstests sollen Fehler nach Änderungen von Komponenten aufdecken, das heißt, dass Regresionstests wiederholbar sein müssen, um das Ergebnis eines alten mit dem Ergebnis eines neuen Testfalls vergleichen zu können.

Hinsichtlich Dokumentation ist das Feld ähnlich vielfältig. Es wird von Code-, API-, Architektur- und Anwenderdokumentation gesprochen.

Trotz aller Unterschiede gibt es eine Gemeinsamkeit: Die genannten Maßnahmen schaffen Vertrauen. Vertrauen in die Funktionalität als solches, in die Integrierbarkeit eines Systems und auch darauf, Änderungen vornehmen zu können.

== Warum sparen wir uns dennoch das Testen?

Konsequente Softwaretests -- so sie denn gesetzlich nicht vorgeschrieben sind -- stehen oftmals hinten an oder sind nicht integraler Bestandteil von Softwareentwicklung. Im Projektalltag habe ich oft Varianten folgender Argumente gehört: "Dafür ist keine Zeit da." und "Testen schafft sowieso keinen Mehrwert.",  "Diese Module sind nicht testbar." oder auch  "Das benutzte Framework macht Tests zu aufwändig."

Dem gegenüber seit entgegnet:

* Die Zeit wird in Summe so oder so aufgewendet. Vielleicht nicht durch dasselbe Team, das einen Service erstellt hat, aber dann durch das Wartungsteam oder den Support. Die nachträgliche Fehlersuche und insbesonder das dann hoffentlich durchgeführte Testen sind teurer.
* Testen schafft Vertrauen. Vertrauen, das Refactorings und neue Features unterstützt und damit direkt Mehrwert entspricht.
* Code, von dem bekannt ist, dass er getestet wird, wird von Anfang an anders und in meinen Augen besser strukturiert, so dass er testbar bleibt

Schleicht sich in einem Projekt Streß ein, sei es durch zeitlichen Druck, unklare Anforderungen oder anderes mehr, ist es zu spät, Testen noch in den Fokus zu rücken. Hinterher Tests zu schreiben bringt oftmals keinen direkten Mehrwert mehr und eine Nachdokumentation macht selten Spaß.

== Anforderungen an Werkzeuge und Tests

Es ergeben sich aus den einleitenden Abschnitten mindestens die folgenden Anforderungen an Tests:

* Der Start eines Projektes darf mit Testunterstützung nicht aufwändiger sein als ohne
* Die Tests müssen sich nahtlos in den Entwicklungsprozess integrieren
* Sie müssen so schnell wie möglich ausführbar sein
* Das Ergebnis sollte meßbar sein

Die Teams hinter Spring und Spring Boot legen großen Wert darauf, dass ihre Frameworks einen test-getriebenen Softwareenwicklungsansatz unterstützen. Meiner Erfahrung nach trifft das zu.

In der Java-Welt hat sich http://junit.org[JUnit] als Standardwerkzeug zur Ausführung von Tests durchgesetzt. JUnit wird von Spring -- auch in der aktuellsten Version 5 -- vollumfänglich unterstützt.

.Spring und Spring Boot
****
Im Januar 2018 wird mein Buch "Spring Boot -- Moderne Softwareentwicklung im Spring-Ökosystem" im dpunkt.verlag erscheinen. Das Buch ist bereits heute unter http://springbootbuch.de[springbootbuch.de] vorbestellbar. Es adressiert sowohl Spring-Neulinge als auch erfahrene Spring-Entwickler, die jetzt mit Spring Boot arbeiten möchten. Hier ein kurzer Auszug, der Ihnen einen Überblick geben soll, was Spring eigentlich ist.

Das Spring-Framework wurde 2002 erstmals als Idee vorgestellt und ein Jahr später unter dem Namen Spring-Framework als quelloffenes Projekt veröffentlicht. Das Ziel -- damals wie heute -- ist die Entwicklung mit Java zu vereinfachen und gute Programmierpraktiken zu fördern.

Kernfunktionen von Spring sind dabei:

* Dependency Injection
* MVC-basierte Webanwendungen und RESTful Webservices
* Grundlagen für JDBC, JPA und vieles mehr
* aspektorientierte Programmierung und deklarative Behandlung von Transaktionen

Spring Boot ist in diesem Kontext kein neues Framework, sondern eine Sicht auf die Spring-Platform, die es ermöglicht, eigenständige und produktionsreife Anwendungen auf Basis des beschriebenen Spring-Frameworks zu bauen, die unter anderem folgende Eigenschaften haben:

* eigenständige Anwendungen, die keine externen Laufzeitabhängigkeiten mehr haben
* automatische Konfiguration
****

Spring-Boot-Anwendungen sind ganz normale Java-Anwendungen, die in der Regel mit einem Build-Management-Tool gebaut werden. Das Build-Management-Tool ist unter anderem für die Auflistung aller Abhängigkeiten zuständig. Im Beispielprojekt zum Artikel verwende ich das Werkzeug https://gradle.org[Gradle].

Spring Boot arbeitet mit sogenannten Startern. Diese Starter stellen Ihnen alle für ein gegebenes Thema notwendigen Abhängigkeiten zur Verfügung. So einen Starter gibt es auch für das Thema Testen.

Die Deklaration der Abhängigkeit in einem Gradle-Build-File (`build.gradle`) ist sehr einfach:

[source,groovy]
.build-gradle
----
include::../../build.gradle[tags=test-dependencies]
----

Durch nur eine Deklaration erhalten Sie:

* JUnit (in der Version 4)
* Springs Test-Support
* http://site.mockito.org[Mockito], eine Mocking-Library, dazu später mehr
* http://joel-costigliola.github.io/assertj[AssertJ], eine Library, die es Ihnen ermöglicht, sehr expressiv Behauptungen zu erwarteten Ergebnissen zu formulieren

== Das Beispiel

Ich möchte Ihnen anhand einer einfachen Fachlichkeit zeigen, wie Spring Boot 2 Ihnen dabei hilft, sehr einfach Integrationstests zu schreiben: Sei es als vollständiger Durchstich oder als Integrationstest auf einer technischen Ebene.

Gestestet werden soll ein Service, der Events und dazugehörige Registrierungen verwaltet. Ein einem Tag können mehrere Events stattfinden, die Namen der Events müssen dabei eindeutig sein. Events haben eine begrenzte Teilnehmeranzahl. Interesierte Besucher melden sich mit Namen und einer E-Mail-Adresse an und sollen sich nicht mehrfach anmelden können. Von einem Event soll zum vorherigen und nächstem Event navigiert werden können. Der Dienst stellt dazu eine einfache Oberfläche zur Verfügung.

Das Thema könnte Teil einer größeren Anwendung sein und als sogenannter Bounded-Context, einem Begriff aus dem Domain-Driven Design, identifiziert worden sein.

Die Fachlichkeit eignet sich außerdem sehr gut, zu zeigen, dass Tests auf Modulebene nicht nur sehr einfach zu realisieren, sondern auch oftmals die wichtigsten Aspekte Ihrer Domain bereits erfassen. Betrachten Sie folgende Java-Klasse

[source,java]
.Event.java
----
include::../main/java/ac/simons/tdd/domain/Event.java[tags=eventStructure]
----
<1> Der Konstruktor überprüft alle geforderten Vorbedingungen. Client-Code kann kein ungültiges Event herstellen
<2> Die Registrierung selber: Es ist nicht notwendig, Logik dieser Art über einen Service zu implementieren und das Event auf ein blutleeres Modell (anemic domain model) zu reduzieren.

Ansonsten ist die Klasse frei von Spring typischen Annotationen. Schauen Sie in den vollständigen Quelltext finden Sie allerdings JPA-Annotationen. JPA steht für _Java Persistence API_ und wird genutzt, um die Inhalte relationaler Datenbanken auf Objekte abzubilden. Richtig genutzt können Sie damit auf der einen Seite gut gestaltete Schemata mit einem Domain-orientierten Ansatz zufriedenstellend zusammen bringen.

== Die Tests

=== Auf Modul-(Unit)-Ebene



== Weitere Herausforderungen

* Continous delivery, schnelle tests
* unabhängiges testen von services
* pro weniger tests


== Just testing

include::../../build/generated-api-doc/get-event/curl-request.adoc[]
include::../../build/generated-api-doc/get-event/http-response.adoc[]
include::../../build/generated-api-doc/get-event/response-fields.adoc[]

== Über den Autor

{author} arbeit als Senior Consultant bei https://www.innoq.com/de/[innoQ Deutschland]. Er ist Mitglied des NetBeans Dream Team und Gründer der Euregio JUG. Michael schreibt in seinem http://info.michael-simons.eu[Blog] über Java, Spring und Softwarearchitektur. {firstname} ist Autor des im Januar 2018 erscheinenden Spring Boot Buches.

Auf Twitter unterwegs als @rotnroll666, unter anderem mit Java, Music und den kleineren und größeren Problemen als Ehemann und Vater von 2 Kindern.